function ensureExists(paramName, param) {
    if (typeof param === 'undefined') {
        throw new Error(`Parameter ${paramName} is requried!`);
    }
}

const priorityMapping = {
    2: 'V',
    3: 'D',
    4: 'I',
    5: 'W',
    6: 'E',
    7: 'A',
};


function getStringParts(str) {
    const parts = [];
    let acc = '';
    let isString = false;
    for (char of str) {
        if (isString) {
            if (char === '"') {
                isString = false;
                parts.push(acc);
                acc = '';
            } else {
                acc += char;
            }
        } else if (char === '"') {
            isString = true;
        }
    }
    return parts;
}

const semver = require('semver');
const argv = require('yargs').argv
const fs = require('fs');
const package = require('./package.json');
require('scribe-js')();
let console = process.console;
const requiredVersions = {
    'log-searcher': '1.1.x',
    'logcat-filter': package.version
};

console.log(`Starting Log-Searcher version [${package.version}]`);

console.warning(`
Expected Input Versions:
log-searcher: [${requiredVersions['log-searcher']}]
logcat-filter: [${requiredVersions['logcat-filter']}]`);

const pathToLogs = argv.logsJSON; //Genereated by ./index.js
const pathToLogAnalysis = argv.logAnalysis; //Generated by log-searcher (https://github.com/isnit0/log-searcher.git)

ensureExists('logsJSON', pathToLogs);
ensureExists('logAnalysis', pathToLogAnalysis);

const recordedLogs = require(pathToLogs);
const logStatements = require(pathToLogAnalysis);

if (!semver.satisfies(recordedLogs.version, requiredVersions['logcat-filter'])) {
    const message = `logsJSON data not a compatible version. Got [${recordedLogs.version}] but expected [${requiredVersions['logcat-filter']}]`;
    console.error(message);
    throw new Error(message);
}

if (!semver.satisfies(logStatements.version, requiredVersions['log-searcher'])) {
    const message = `logAnalysis data not a compatible version. Got [${logStatements.version}] but expected [${requiredVersions['log-searcher']}]`;
    console.error(message);
    throw new Error(message);
}

const logsByPriority = recordedLogs.data
    .reduce((acc, log) => {
        acc[priorityMapping[log.priority]] = acc[priorityMapping[log.priority]] || [];
        acc[priorityMapping[log.priority]].push(log);
        return acc;
    }, {});

const coverageReportData = Object.keys(logStatements.data)
    .reduce((acc, filename) => {
        const statements = logStatements.data[filename].map(log => {
            const isCovered = matchStatementToLogs(log, recordedLogs.data);
            return {
                originalLog: log,
                isCovered
            };
        });
        acc[filename] = statements;
        return acc;
    }, {});


function matchStatementToLogs(log, recordedLogs) {
    const stringParts = getStringParts(log.message);
    return !!recordedLogs.find(rLog => { // rLog contains each of the string parts
        return stringParts.every(part => !!~rLog.message.indexOf(part));
    });
}


console.info(`Writing to ./reportData.json`);

fs.writeFileSync(`./reportData.json`, JSON.stringify({
    version: package.version,
    header: {
        deviceInfo: recordedLogs.header.device,
        generatedAt: Date.now(),
        package: recordedLogs.header.package
    },
    data: coverageReportData
}));

console.info(`Successfully written to file

*---------------------------------------*
| To view the data, run "npm run serve" |
*---------------------------------------*\n`)